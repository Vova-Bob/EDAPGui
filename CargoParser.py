from __future__ import annotations

import json
import os
import time
from datetime import datetime, timedelta
import queue
from sys import platform
import threading
from time import sleep
from typing import Callable, Optional

from simple_localization.localization import LocalizationManager

from EDlogger import logger
from WindowsKnownPaths import *


class CargoParser:
    """ Parses the Cargo.json file generated by the game. """

    _fallback_locale = None
    _fallback_locale_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'locales')

    def __init__(self, file_path=None, log_func: Optional[Callable[..., str]] = None):
        if platform != "win32":
            self.file_path = file_path if file_path else "./linux_ed/Cargo.json"
        else:
            from WindowsKnownPaths import get_path, FOLDERID, UserHandle

            self.file_path = file_path if file_path else (get_path(FOLDERID.SavedGames, UserHandle.current)
                                                          + "/Frontier Developments/Elite Dangerous/Cargo.json")
        self.last_mod_time = None
        self.resource_name = os.path.basename(self.file_path)
        self._log_func = log_func

        # Read json file data
        self.current_data = self.get_cargo_data()

        # self.watch_thread = threading.Thread(target=self._watch_file_thread, daemon=True)
        # self.watch_thread.start()
        # self.status_queue = queue.Queue()

    @classmethod
    def _get_fallback_locale(cls) -> LocalizationManager:
        if cls._fallback_locale is None:
            language = os.environ.get('EDAP_LOCALE', 'en')
            try:
                cls._fallback_locale = LocalizationManager(cls._fallback_locale_dir, language)
            except Exception:
                cls._fallback_locale = LocalizationManager(cls._fallback_locale_dir, 'en')
        return cls._fallback_locale

    def _t(self, key: str, **kwargs) -> str:
        try:
            text = self._get_fallback_locale()[key]
        except Exception:
            return key
        if kwargs:
            try:
                return text.format(**kwargs)
            except (KeyError, ValueError):
                return text
        return text

    # def _watch_file_thread(self):
    #     backoff = 1
    #     while True:
    #         try:
    #             self._watch_file()
    #         except Exception as e:
    #             logger.debug('An error occurred when reading status file')
    #             sleep(backoff)
    #             logger.debug('Attempting to restart status file reader after failure')
    #             backoff *= 2
    #
    # def _watch_file(self):
    #     """Detects changes in the Status.json file."""
    #     while True:
    #         status = self.get_cleaned_data()
    #         if status != self.current_data:
    #             self.status_queue.put(status)
    #             self.current_data = status
    #         sleep(1)

    def get_file_modified_time(self) -> float:
        return os.path.getmtime(self.file_path)

    def get_cargo_data(self):
        """Loads data from the JSON file and returns the data.
        { "timestamp":"2025-04-20T23:23:25Z", "event":"Cargo", "Vessel":"Ship", "Count":0, "Inventory":[

         ] }
        """
        # Check if file changed
        if self.get_file_modified_time() == self.last_mod_time:
            #logger.debug(f'Cargo.json mod timestamp {self.last_mod_time} unchanged.')
            return self.current_data

        # Read file
        backoff = 1
        while True:
            try:
                with open(self.file_path, 'r', encoding='utf-8') as file:
                    data = json.load(file)
                    break
            except Exception as e:
                self._log('log.cargo.read_error', level='warning', error=str(e), resource=self.file_path)
                sleep(backoff)
                self._log('log.status.retry_attempt', level='debug', resource=self.resource_name, delay=backoff)
                backoff *= 2

        # Store data
        self.current_data = data
        self.last_mod_time = self.get_file_modified_time()
        #logger.debug(f'Cargo.json mod timestamp {self.last_mod_time} updated.')
        # print(json.dumps(data, indent=4))
        return data

    def _log(self, key: str, *, level: str = 'info', **kwargs):
        if self._log_func:
            try:
                self._log_func(key, level=level, **kwargs)
                return
            except Exception as exc:
                logger.debug(f"Failed to emit localized log '{key}': {exc}")

        message = self._t(key, **kwargs)
        log_method = getattr(logger, level.lower(), logger.info)
        log_method(message)

    def get_item(self, item_name: str) -> dict[any] | None:
        """ Get details of one item. Returns the item detail as below, or None if item does not exist.
            Will not trigger a read of the json file.
        {
            "Name":"cmmcomposite",
            "Name_Localised":"CMM Composite", {This is optional}
            "Count":1236,
            "Stolen":0
        }
        @param item_name: The commodity name.
        @return: Details on the commodity if in hold, else None.
        """
        for good in self.current_data['Inventory']:
            if good['Name'].upper() == item_name.upper():
                # print(json.dumps(good, indent=4))
                return good
            if 'Name_Localised' in good:
                if good['Name_Localised'].upper() == item_name.upper():
                    # print(json.dumps(good, indent=4))
                    return good
        return None


# Usage Example
if __name__ == "__main__":
    cargo_parser = CargoParser()
    while True:
        cleaned_data = cargo_parser.get_cargo_data()
        item = cargo_parser.get_item('Tritium')
        time.sleep(1)
